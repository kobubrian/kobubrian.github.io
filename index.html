<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8"/>
  <title>Blackbox</title>
  <style>
    table {
      border-collapse: collapse;
      margin-top: 1rem;
    }
    th, td {
      border: 1px solid #000;
      width: 70px;
      height: 70px;
      text-align: center;
      vertical-align: middle;
      font-family: monospace;
      font-size: 50px;
    }
    th {
      background-color: #ddd;
      width: 70px;
    }
    .beam-entry {
      background-color: yellow; 
    }
    .beam-exit {
      background-color: green; 
    }
    .beam-split {
      background: linear-gradient(to bottom right, yellow 50%, green 50%);
    }
    /* Triangles hidden by default */
    .triangle {
      color: transparent;
    }
    #feedback,
    #guessFeedback {
      margin-top: 1rem;
      padding: 10px;
      border: 1px solid #666;
      font-family: monospace;
      background: #f9f9f9;
    }
  </style>
</head>
<body>

<h1>Blackbox</h1>

<!-- Beam Input -->
<div>
  <p><strong>Fire a Beam</strong><br>
    Type an entry label from the edges:
  </p>
  <ul>
    <li>Top: A–D</li>
    <li>Left: 1–4</li>
    <li>Right: 5–8</li>
    <li>Bottom: E–H</li>
  </ul>
  <input type="text" id="beamEntry" style="width: 40px;" />
  <button onclick="fireBeam()">Fire Beam</button>
</div>

<!-- Feedback Panel -->
<div id="feedback">
  <strong>Shot Feedback:</strong><br/>
</div>

<!-- Guessing Game -->
<div>
  <strong>Guess a Triangle!</strong><br/>
  - Enter a cell in "row-col" format, e.g. "0-1"<br/>
  - Rows/Cols range from 0..3
  <br/><br/>
  <input type="text" id="triangleGuess" style="width: 80px;" />
  <button onclick="guessTriangle()">Guess</button>
</div>

<div id="guessFeedback">
  <strong>Guess Feedback:</strong><br/>
</div>

<!-- Grid with axis around all sides -->
<table>
  <tbody id="outerGrid"></tbody>
</table>

<script>
/** 
 * CONFIG & GLOBALS
 */
const rows = 4;         
const cols = 4;         

/* Edge labels */
const topLabels = ["A","B","C","D"];   
const leftLabels = ["1","2","3","4"];  
const rightLabels = ["5","6","7","8"];
const bottomLabels = ["E","F","G","H"];

/** 
 * We'll store the triangles in a 2D array:
 * Each cell is either null or one of the corner chars: ┌, ┐, └, ┘
 */
let gridData;
let totalTriangles;
let guessCount;
let shotCount;

/**
 * Keep track of which cells have been guessed
 * so we don't remove triangles from the grid.
 */
let guessedPositions; // set of "r-c" strings

/** NEW GAME (INIT) */
function newGame() {
  totalTriangles = 3;
  guessCount = 0;
  shotCount = 0;
  guessedPositions = new Set();
  
  // Clear feedback
  document.getElementById("feedback").innerHTML = "<strong>Shot Feedback:</strong><br/>";
  document.getElementById("guessFeedback").innerHTML = "<strong>Guess Feedback:</strong><br/>";
  
  // Initialize the grid data
  gridData = Array.from({ length: rows }, () => Array(cols).fill(null));
  placeTriangles();
  buildOuterGrid();
}

/** 
 * Place 3 triangles randomly (hidden).
 */
function placeTriangles() {
  const corners = ["┌","┐","└","┘"];
  let count = 0;
  while (count < 3) {
    let r = Math.floor(Math.random() * rows);
    let c = Math.floor(Math.random() * cols);
    if (!gridData[r][c]) {
      gridData[r][c] = corners[Math.floor(Math.random() * corners.length)];
      count++;
    }
  }
}

function resetBeamCells() {
  // Remove all `beam-exit` classes
  const exitCells = document.querySelectorAll(".beam-exit");
  exitCells.forEach(cell => cell.classList.remove("beam-exit"));

  // Replace all `beam-split` with `beam-entry`
  const splitCells = document.querySelectorAll(".beam-split");
  splitCells.forEach(cell => {
    cell.classList.remove("beam-split");
    if (!cell.classList.contains("beam-entry")) {
      cell.classList.add("beam-entry");
    }
  });
}

/**
 * Reflection for each corner type.
 */
function reflectCorner(corner, incoming) {
  // ┌ (UL)
  if (corner === "┌") {
    if (incoming === "U") return "R";
    if (incoming === "D") return "U";
    if (incoming === "L") return "D";
    if (incoming === "R") return "L";
  }
  // ┐ (UR)
  if (corner === "┐") {
    if (incoming === "U") return "L";
    if (incoming === "D") return "U";
    if (incoming === "L") return "R";
    if (incoming === "R") return "D";
  }
  // └ (DL)
  if (corner === "└") {
    if (incoming === "U") return "D";
    if (incoming === "D") return "R";
    if (incoming === "L") return "U";
    if (incoming === "R") return "L";
  }
  // ┘ (DR)
  if (corner === "┘") {
    if (incoming === "U") return "D";
    if (incoming === "D") return "L";
    if (incoming === "L") return "R";
    if (incoming === "R") return "U";
  }
  return incoming;
}

/** Build a 6x6 "outerGrid" (table) with axis labels */
function buildOuterGrid() {
  const outer = document.getElementById("outerGrid");
  outer.innerHTML = "";

  // Top row
  let topRow = document.createElement("tr");
  topRow.appendChild(document.createElement("th")); 
  for (let c = 0; c < cols; c++) {
    let th = document.createElement("th");
    th.textContent = topLabels[c];
    topRow.appendChild(th);
  }
  topRow.appendChild(document.createElement("th"));
  outer.appendChild(topRow);

  // Middle rows
  for (let r = 0; r < rows; r++) {
    let rowEl = document.createElement("tr");
    let leftTh = document.createElement("th");
    leftTh.textContent = leftLabels[r];
    rowEl.appendChild(leftTh);

    for (let c = 0; c < cols; c++) {
      let td = document.createElement("td");
      td.id = `${r}-${c}`; 
      // Triangles hidden by default
      td.textContent = ""; 
      td.classList.add("triangle");

      rowEl.appendChild(td);
    }
    let rightTh = document.createElement("th");
    rightTh.textContent = rightLabels[r];
    rowEl.appendChild(rightTh);

    outer.appendChild(rowEl);
  }

  // Bottom row
  let bottomRow = document.createElement("tr");
  bottomRow.appendChild(document.createElement("th"));
  for (let c = 0; c < cols; c++) {
    let th = document.createElement("th");
    th.textContent = bottomLabels[c];
    bottomRow.appendChild(th);
  }
  bottomRow.appendChild(document.createElement("th"));
  outer.appendChild(bottomRow);
}

/** Parse user entry for firing beams */
function parseBeamEntry(entry) {
  entry = entry.trim().toUpperCase();

  if (topLabels.includes(entry)) {
    let c = topLabels.indexOf(entry);
    return { row: -1, col: c, dir: "D" };
  }
  if (leftLabels.includes(entry)) {
    let r = leftLabels.indexOf(entry);
    return { row: r, col: -1, dir: "R" };
  }
  if (rightLabels.includes(entry)) {
    let r = rightLabels.indexOf(entry);
    return { row: r, col: cols, dir: "L" };
  }
  if (bottomLabels.includes(entry)) {
    let c = bottomLabels.indexOf(entry);
    return { row: rows, col: c, dir: "U" };
  }
  return null;
}

/** Fire the beam! */
function fireBeam() {
  shotCount++;
  const inputVal = document.getElementById("beamEntry").value.trim().toUpperCase();
  if (!inputVal) {
    alert("Please type an edge label (A–D, 1–4, 5–8, E–H).");
    return;
  }

  const start = parseBeamEntry(inputVal);
  if (!start) {
    alert("Invalid entry. Valid edges: A–D, 1–4, 5–8, E–H.");
    return;
  }
  resetBeamCells();
  
  let { row: r, col: c, dir: d } = start;

  // Immediate reflection if there's a triangle on entry
  if (gridData[r] && gridData[r][c]) {
    d = reflectCorner(gridData[r][c], d);
    markBeamCell(r, c, "entry");
  } else {
    markBeamCell(r, c, "entry");
  }
  
  while (true) {
    ({ r, c } = stepOne(r, c, d));
    if (r < 0 || r >= rows || c < 0 || c >= cols) break;
    if (gridData[r][c]) d = reflectCorner(gridData[r][c], d);
  }

  markBeamCell(r, c, "exit");

  const exitLabel = findExitLabel(r, c);
  document.getElementById("feedback").innerHTML = 
    `<strong>Shot Fired #${shotCount}:</strong> Entered at ${inputVal} (${start.dir}) Exited at ${
      exitLabel} (${d})<br/>`;
}

/** Move one step in the given direction */
function stepOne(r, c, dir) {
  if (dir === "U") r--;
  if (dir === "D") r++;
  if (dir === "L") c--;
  if (dir === "R") c++;
  return { r, c };
}

/** Find the exit label for row/col */
function findExitLabel(r, c) {
  if (r < 0) return topLabels[c];
  if (r >= rows) return bottomLabels[c];
  if (c < 0) return leftLabels[r];
  if (c >= cols) return rightLabels[r];
  return null;
}

/** Mark beam cells */
function markBeamCell(r, c, type) {
  let cell;
  if (r < 0) { 
    cell = document.querySelector(`tr:first-child th:nth-child(${c + 2})`);
  } else if (r >= rows) { 
    cell = document.querySelector(`tr:last-child th:nth-child(${c + 2})`);
  } else if (c < 0) { 
    cell = document.querySelector(`tr:nth-child(${r + 2}) th:first-child`);
  } else if (c >= cols) {
    cell = document.querySelector(`tr:nth-child(${r + 2}) th:last-child`);
  } else { 
    cell = document.getElementById(`${r}-${c}`);
  }

  if (cell) {
    if (type === "entry") {
      if (cell.classList.contains("beam-exit")) {
        cell.className = "beam-split";
      } else {
        cell.className = "beam-entry";
      }
    } else if (type === "exit") {
      if (cell.classList.contains("beam-entry")) {
        cell.className = "beam-split";
      } else {
        cell.className = "beam-exit";
      }
    }
  }
}

/** Guess a triangle's position */
function guessTriangle() {
  guessCount++;
  const guessVal = document.getElementById("triangleGuess").value.trim();
  const [gr, gc] = guessVal.split("-");
  
  // Validate
  if (isNaN(gr) || isNaN(gc) || gr < 0 || gr >= rows || gc < 0 || gc >= cols) {
    document.getElementById("guessFeedback").innerHTML = 
      "Invalid guess. Use row-col, e.g. '0-1' (rows/cols: 0..3)";
    return;
  }

  // Example: track duplicates if desired, using a set
  // (omitted if you already have that logic)

  // Check for triangle
  if (gridData[gr][gc]) {
    // DO NOT remove it from gridData!
    // Instead, just reveal it visually.
    let foundCorner = gridData[gr][gc];

    // Show it in red
    const cell = document.getElementById(`${gr}-${gc}`);
    cell.textContent = foundCorner;
    cell.classList.add("triangle");
    cell.style.color = "red";

    totalTriangles--;
    document.getElementById("guessFeedback").innerHTML = `
      <strong>Hit!</strong> You found a triangle at [${guessVal}].
      <br>Triangles left: ${totalTriangles}
      <br>Guesses so far: ${guessCount}
    `;

    // If all found, end game
    if (totalTriangles === 0) {
      document.getElementById("guessFeedback").innerHTML = `
        <strong>All Triangles Found!</strong><br>
        You took ${guessCount} guesses and fired ${shotCount} shots.<br>
        <button onclick="newGame()">Play Again</button>
      `;
    }
  } else {
    document.getElementById("guessFeedback").innerHTML = `
      <strong>Miss!</strong> No triangle at [${guessVal}].
      <br>Guesses so far: ${guessCount}
    `;
  }
}

/** Init the game on load */
window.onload = newGame;
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8"/>
  <title>Blackbox</title>
  <style>
    table {
      border-collapse: collapse;
      margin-top: 1rem;
    }
    th, td {
      border: 1px solid #000;
      width: 70px;
      height: 70px;
      text-align: center;
      vertical-align: middle;
      font-family: monospace;
      font-size: 50px;
    }
    td {
        position: relative;
        border: 1px solid #000;
        width: 70px;
        height: 70px;
        text-align: center;
        vertical-align: middle;
        font-family: monospace;
        font-size: 50px;
        transition: background-color 0.2s ease; /* Smooth hover effect */
    }

    /* Label Styling */
    td div {
        position: absolute;
        top: 4px;
        left: 4px;
        font-size: 14px;
        color: rgba(0, 0, 0, 0.6); /* Light gray for better visibility */
        pointer-events: none;
        font-weight: bold;
    }

    /* Highlight Cell on Hover */
    td:hover {
        background-color: rgba(0, 0, 255, 0.1); /* Light blue hover effect */
        cursor: pointer; 
    }

    th {
      background-color: #ddd;
      width: 70px;
    }
    .beam-entry {
      background-color: yellow; 
    }
    .beam-exit {
      background-color: green; 
    }
    .beam-split {
      background: linear-gradient(to bottom right, yellow 50%, green 50%);
    }
    /* Triangles hidden by default */
    .triangle {
      color: transparent;
    }
    td div {
        position: absolute;
        top: 2px;
        left: 4px;
        pointer-events: none; /* Prevent clicks on labels */
    }
    #feedback,
    #guessFeedback {
      margin-top: 1rem;
      padding: 10px;
      border: 1px solid #666;
      font-family: monospace;
      background: #f9f9f9;
    }
  </style>
</head>
<body>

<h1>Blackbox</h1>

<!-- Beam Input -->
<div>
  <p><strong>Fire a Beam</strong><br>
    Type an entry label from the edges:
  </p>
  <ul>
    <li>Top: A–D</li>
    <li>Left: 1–4</li>
    <li>Right: 5–8</li>
    <li>Bottom: E–H</li>
  </ul>
  <input type="text" id="beamEntry" style="width: 40px;" />
  <button onclick="fireBeam()">Fire Beam</button>
</div>

<!-- Feedback Panel -->
<div id="feedback">
  <strong>Shot Feedback:</strong><br/>
</div>

<!-- Guessing Game -->
<strong>Guess a Triangle!</strong><br/>
- Enter a cell like "A1", "B2", "D4"<br/>
- Choose triangle type: 
<select id="triangleTypeGuess">
  <option value="UL">Upper Left (UL)</option>
  <option value="UR">Upper Right (UR)</option>
  <option value="DL">Down Left (DL)</option>
  <option value="DR">Down Right (DR)</option>
</select><br/>
<input type="text" id="triangleGuess" style="width: 80px;" />
<button onclick="guessTriangle()">Guess</button>


<div id="guessFeedback">
  <strong>Guess Feedback:</strong><br/>
</div>

<!-- Grid with axis around all sides -->
<table>
  <tbody id="outerGrid"></tbody>
</table>

<script>
/** 
 * CONFIG & GLOBALS
 */
const rows = 4;         
const cols = 4;         

/* Edge labels */
const topLabels = ["A","B","C","D"];   
const leftLabels = ["1","2","3","4"];  
const rightLabels = ["5","6","7","8"];
const bottomLabels = ["E","F","G","H"];

/** 
 * We'll store the triangles in a 2D array:
 * Each cell is either null or one of the corner chars: ┌, ┐, └, ┘
 */
let gridData;
let totalTriangles;
let guessCount;
let shotCount;

/**
 * Keep track of which cells have been guessed
 * so we don't remove triangles from the grid.
 */
 let guessedPositions; // Map: key = "r-c", value = Set of guessed triangle types
let solvedCells;       // New Set to track fully solved cells


/** NEW GAME (INIT) */
function newGame() {
  totalTriangles = 3;
  guessCount = 0;
  shotCount = 0;
  guessedPositions = new Map();
    solvedCells = new Set();  // Initialize the solved cells tracker

  
  // Clear feedback
  document.getElementById("feedback").innerHTML = "<strong>Shot Feedback:</strong><br/>";
  document.getElementById("guessFeedback").innerHTML = "<strong>Guess Feedback:</strong><br/>";
  
  // Initialize the grid data
  gridData = Array.from({ length: rows }, () => Array(cols).fill(null));
  placeTriangles();
  buildOuterGrid();
}

/** 
 * Place 3 triangles randomly (hidden).
 */
function placeTriangles() {
    const corners = {
  "UL": "Triangle-UL.png",
  "UR": "Triangle-UR.png",
  "DL": "Triangle-DL.png",
  "DR": "Triangle-DR.png"
    };

  let count = 0;
  while (count < 3) {
    let r = Math.floor(Math.random() * rows);
    let c = Math.floor(Math.random() * cols);
    if (!gridData[r][c]) {
      gridData[r][c] = Object.values(corners)[Math.floor(Math.random() * 4)];
      count++;
    }
  }
}

function resetBeamCells() {
  // Remove all `beam-exit` classes
  const exitCells = document.querySelectorAll(".beam-exit");
  exitCells.forEach(cell => cell.classList.remove("beam-exit"));

  // Replace all `beam-split` with `beam-entry`
  const splitCells = document.querySelectorAll(".beam-split");
  splitCells.forEach(cell => {
    cell.classList.remove("beam-split");
    if (!cell.classList.contains("beam-entry")) {
      cell.classList.add("beam-entry");
    }
  });
}

/**
 * Reflection for each corner type.
 */
 function reflectCorner(cornerImage, incoming) {
  // Map images to their triangle directions
  const mapping = {
    "Triangle-UL.png": "UL",
    "Triangle-UR.png": "UR",
    "Triangle-DL.png": "DL",
    "Triangle-DR.png": "DR"
  };

  const corner = mapping[cornerImage];

  if (corner === "UL") { // Upper Left (like ┌)
    if (incoming === "U") return "R";
    if (incoming === "D") return "U";
    if (incoming === "L") return "D";
    if (incoming === "R") return "L";
  }
  if (corner === "UR") { // Upper Right (like ┐)
    if (incoming === "U") return "L";
    if (incoming === "D") return "U";
    if (incoming === "L") return "R";
    if (incoming === "R") return "D";
  }
  if (corner === "DL") { // Down Left (like └)
    if (incoming === "U") return "D";
    if (incoming === "D") return "R";
    if (incoming === "L") return "U";
    if (incoming === "R") return "L";
  }
  if (corner === "DR") { // Down Right (like ┘)
    if (incoming === "U") return "D";
    if (incoming === "D") return "L";
    if (incoming === "L") return "R";
    if (incoming === "R") return "U";
  }

  return incoming; // Default: no reflection
}
function autoFillGuess(row, col) {
  const coordinate = `${String.fromCharCode(65 + col)}${row + 1}`; // Converts to A1, B2, etc.
  document.getElementById("triangleGuess").value = coordinate;     // Auto-fill the input field
  //guessTriangle();                                                // Automatically make the guess
}


/** Build a 6x6 "outerGrid" (table) with axis labels */
function buildOuterGrid() {
  const outer = document.getElementById("outerGrid");
  outer.innerHTML = "";

  // Top row
  let topRow = document.createElement("tr");
  topRow.appendChild(document.createElement("th")); 
  for (let c = 0; c < cols; c++) {
    let th = document.createElement("th");
    th.textContent = topLabels[c];
    topRow.appendChild(th);
  }
  topRow.appendChild(document.createElement("th"));
  outer.appendChild(topRow);

  // Middle rows
  for (let r = 0; r < rows; r++) {
    let rowEl = document.createElement("tr");
    let leftTh = document.createElement("th");
    leftTh.textContent = leftLabels[r];
    rowEl.appendChild(leftTh);

    for (let c = 0; c < cols; c++) {
      let td = document.createElement("td");
      td.id = `${r}-${c}`;
      td.onclick = function() { autoFillGuess(r, c); };  // Add this line

      // Triangles hidden by default
      td.innerHTML = `<div style="opacity: 0.3; font-size: 12px;">${String.fromCharCode(65 + c)}${r + 1}</div>`;
      td.classList.add("triangle");

      rowEl.appendChild(td);
    }
    let rightTh = document.createElement("th");
    rightTh.textContent = rightLabels[r];
    rowEl.appendChild(rightTh);

    outer.appendChild(rowEl);
  }

  // Bottom row
  let bottomRow = document.createElement("tr");
  bottomRow.appendChild(document.createElement("th"));
  for (let c = 0; c < cols; c++) {
    let th = document.createElement("th");
    th.textContent = bottomLabels[c];
    bottomRow.appendChild(th);
  }
  bottomRow.appendChild(document.createElement("th"));
  outer.appendChild(bottomRow);
}

/** Parse user entry for firing beams */
function parseBeamEntry(entry) {
  entry = entry.trim().toUpperCase();

  if (topLabels.includes(entry)) {
    let c = topLabels.indexOf(entry);
    return { row: -1, col: c, dir: "D" };
  }
  if (leftLabels.includes(entry)) {
    let r = leftLabels.indexOf(entry);
    return { row: r, col: -1, dir: "R" };
  }
  if (rightLabels.includes(entry)) {
    let r = rightLabels.indexOf(entry);
    return { row: r, col: cols, dir: "L" };
  }
  if (bottomLabels.includes(entry)) {
    let c = bottomLabels.indexOf(entry);
    return { row: rows, col: c, dir: "U" };
  }
  return null;
}

/** Fire the beam! */
function fireBeam() {
  shotCount++;
  const inputVal = document.getElementById("beamEntry").value.trim().toUpperCase();
  if (!inputVal) {
    alert("Please type an edge label (A–D, 1–4, 5–8, E–H).");
    return;
  }

  const start = parseBeamEntry(inputVal);
  if (!start) {
    alert("Invalid entry. Valid edges: A–D, 1–4, 5–8, E–H.");
    return;
  }
  resetBeamCells();
  
  let { row: r, col: c, dir: d } = start;

  // Immediate reflection if there's a triangle on entry
  if (gridData[r] && gridData[r][c]) {
    d = reflectCorner(gridData[r][c], d);
    markBeamCell(r, c, "entry");
  } else {
    markBeamCell(r, c, "entry");
  }
  
  while (true) {
    ({ r, c } = stepOne(r, c, d));
    if (r < 0 || r >= rows || c < 0 || c >= cols) break;
    if (gridData[r][c]) d = reflectCorner(gridData[r][c], d);
  }

  markBeamCell(r, c, "exit");

  const exitLabel = findExitLabel(r, c);
  document.getElementById("feedback").innerHTML = 
    `<strong>Shot Fired #${shotCount}:</strong> Entered at ${inputVal} (${start.dir}) Exited at ${
      exitLabel} (${d})<br/>`;
}

/** Move one step in the given direction */
function stepOne(r, c, dir) {
  if (dir === "U") r--;
  if (dir === "D") r++;
  if (dir === "L") c--;
  if (dir === "R") c++;
  return { r, c };
}

/** Find the exit label for row/col */
function findExitLabel(r, c) {
  if (r < 0) return topLabels[c];
  if (r >= rows) return bottomLabels[c];
  if (c < 0) return leftLabels[r];
  if (c >= cols) return rightLabels[r];
  return null;
}

/** Mark beam cells */
function markBeamCell(r, c, type) {
  let cell;
  if (r < 0) { 
    cell = document.querySelector(`tr:first-child th:nth-child(${c + 2})`);
  } else if (r >= rows) { 
    cell = document.querySelector(`tr:last-child th:nth-child(${c + 2})`);
  } else if (c < 0) { 
    cell = document.querySelector(`tr:nth-child(${r + 2}) th:first-child`);
  } else if (c >= cols) {
    cell = document.querySelector(`tr:nth-child(${r + 2}) th:last-child`);
  } else { 
    cell = document.getElementById(`${r}-${c}`);
  }

  if (cell) {
    if (type === "entry") {
      if (cell.classList.contains("beam-exit")) {
        cell.className = "beam-split";
      } else {
        cell.className = "beam-entry";
      }
    } else if (type === "exit") {
      if (cell.classList.contains("beam-entry")) {
        cell.className = "beam-split";
      } else {
        cell.className = "beam-exit";
      }
    }
  }
}

/** Guess a triangle's position */
function guessTriangle() {
  const guessVal = document.getElementById("triangleGuess").value.trim();
  const triangleTypeGuess = document.getElementById("triangleTypeGuess").value;

  const colLetter = guessVal[0]?.toUpperCase();
  const rowNumber = parseInt(guessVal.slice(1));
  const gr = rowNumber - 1;
  const gc = colLetter?.charCodeAt(0) - "A".charCodeAt(0);
  const guessKey = `${gr}-${gc}`;

  if (isNaN(gr) || isNaN(gc) || gr < 0 || gr >= rows || gc < 0 || gc >= cols) {
    document.getElementById("guessFeedback").innerHTML = 
      "Invalid guess. Guess something like A2.";
    return;
  }

  // 🚫 Check if the cell is already solved
  if (solvedCells.has(guessKey)) {
    document.getElementById("guessFeedback").innerHTML = 
      `You've already correctly guessed the triangle at [${guessVal}]. Try a different cell.`;
    return;
  }

  // Track guesses for each cell
  if (!guessedPositions.has(guessKey)) {
    guessedPositions.set(guessKey, new Set());
  }

  const guessedTypes = guessedPositions.get(guessKey);

  // Prevent duplicate guesses for the same triangle type
  if (guessedTypes.has(triangleTypeGuess)) {
    document.getElementById("guessFeedback").innerHTML = 
      `You've already guessed [${guessVal}] with ${triangleTypeGuess}. Try a different type or cell.`;
    return;
  }

  guessedTypes.add(triangleTypeGuess);
  guessCount++;

  const cell = document.getElementById(`${gr}-${gc}`);
  const triangleAtCell = gridData[gr][gc];

  const triangleMapping = {
    "Triangle-UL.png": "UL",
    "Triangle-UR.png": "UR",
    "Triangle-DL.png": "DL",
    "Triangle-DR.png": "DR"
  };

  if (triangleAtCell && triangleMapping[triangleAtCell] === triangleTypeGuess) {
    // ✅ Correct Guess
    cell.innerHTML = `<img src="${triangleAtCell}" alt="Triangle" width="50" height="50">`;
    cell.classList.add("triangle");

    totalTriangles--;
    solvedCells.add(guessKey);  // 🚀 Mark this cell as solved

    document.getElementById("guessFeedback").innerHTML = `
      <strong>Hit!</strong> You found a ${triangleTypeGuess} triangle at [${guessVal}].<br>
      Triangles left: ${totalTriangles}<br>
      Guesses so far: ${guessCount}
    `;

    if (totalTriangles === 0) {
      document.getElementById("guessFeedback").innerHTML = `
        <strong>All Triangles Found!</strong><br>
        You took ${guessCount} guesses and fired ${shotCount} shots.<br>
        <button onclick="newGame()">Play Again</button>
      `;
    }
  } else if (triangleAtCell) {
    // ❗ Wrong Type
    cell.style.backgroundColor = "orange";
    document.getElementById("guessFeedback").innerHTML = `
      <strong>Close!</strong> There's a triangle at [${guessVal}], but it's not a ${triangleTypeGuess}.<br>
      Guesses so far: ${guessCount}
    `;
  } else {
    // ❌ No Triangle
    cell.style.backgroundColor = "lightgray";
    document.getElementById("guessFeedback").innerHTML = `
      <strong>Miss!</strong> No triangle at [${guessVal}].<br>
      Guesses so far: ${guessCount}
    `;
  }
}


//LLALALAL



/** Init the game on load */
window.onload = newGame;
</script>
</body>
</html>